###############################################################################
# This script loads in either one or two VCF files, each generated by mapping 
# and calling variants against one of the two parental reference sequences, 
# converts them to data.frames, adjusts position indicies to a common 
# reference, and extracts SNPs. It then reconciles the two callsets at each
# SNP position based on genotype likelihoods (GQ scores). It filters out
# low confidence calls based on read depth and allele balance. 
# The script requires objects from the 01_initialize_project.R script and 
# functions from the import_functions.R and analysis_functions.R scripts.
# The expected VCF format is a multi-sample VCF output from GATK, and may 
# contain a combination of founders and/or end-point clones.
# The output is essentially a single VCF table of reconciled calls with no 
# header.
###############################################################################

# Generate master SNP dataframe from all clone data aligned to each reference
merge_cols <- c("CHROM", "POS", "POSi", "QUAL", "REF", "ALT", "GT", "Ref_DP", "Alt_DP",
                "GQ", "ID")
by_cols <- c("CHROM", "POS", "POSi", "ID")

# Load in Parent 1 vcf file and filter out low depth sites
all_var_P1 <- HC_multiVcfParse_allVar(P1_file, all_Alts = F) %>% 
  filter(Sum_DP >= 6) %>% select(all_of(merge_cols))

# all_var_P1_file <- "~/SK_Lab/PhD_Projects/LOH_methods/Overton_etal_2022/data/int/Overton_allVar_P1_2023_08.RData"
# save(all_var_P1, file = all_var_P1_file)
# all_var_P1 <- all_var_P1 %>% filter(grepl("F_A", ID))

# Translate positions for P1 callset to Ref positions

if(P1 != "S288C") {
all_var_P1 <- all_var_P1 %>%
  ConstructLiftover(.,  chain_df = P1toRefChainDf, 
                    chrom_from = chrom_bounds_P1,
                    chrom_to = chrom_bounds_Ref)
# 
# all_var_P1_lo <- all_var_P1 %>% 
#   filter(ID == "F_A00") %>%
#   ConstructLiftover(.,  chain_df = P1toRefChainDf, 
#                     chrom_from = chrom_bounds_P1,
#                     chrom_to = chrom_bounds_Ref)

}

iSNP_P1 <- nchar(all_var_P1$REF) == 1 & nchar(all_var_P1$ALT) == 1 

if(P1_only) {

  SNPs_merge_finalGT <- all_var_P1 %>%
    filter(iSNP_P1, GT != "./.", GQ >= 30) %>%
    rename(QUAL_P1call = QUAL, Ref_DP_final = Ref_DP, Alt_DP_final = Alt_DP) %>%
    mutate(QUAL_P2call = 9999) %>%
    arrange(ID, POSi)
  
  rm(all_var_P1)
  
  # Remove sites that are in the rRNA repeat region and known Ty elements
  ###############################################################################
  
  rRNA_POSi_seq <- SNPs_merge_finalGT %>% distinct(POSi) %>% 
    filter(POSi >= rRNA_POSi$POSi[1], POSi <= rRNA_POSi$POSi[2]) %>% pull(POSi)
  SNPs_merge_finalGT <- SNPs_merge_finalGT %>% filter(!POSi %in% rRNA_POSi_seq)
  
  Ty_POSi_seq <- SNPs_merge_finalGT %>% distinct(POSi) %>% 
    filter(POSi >= Ty_POSi$POSi[1], POSi <= Ty_POSi$POSi[2]) %>% pull(POSi)
  SNPs_merge_finalGT <- SNPs_merge_finalGT %>% filter(!POSi %in% Ty_POSi_seq)
  
  SNPs_merge_finalGT$repeats <- MarkRepeats(SNPs_merge_finalGT, repeats_in = repeats_bed)
  SNPs_merge_finalGT <- SNPs_merge_finalGT %>% filter(!repeats) %>% select(-repeats)
  
} else {
  
  # Load Parent 2 callset
  all_var_P2 <- HC_multiVcfParse_allVar(P2_file, all_Alts = F, verbose = T) %>% 
    filter(Sum_DP >= 6) %>% select(all_of(merge_cols))
  all_var_P2_raw <- all_var_P2
  # all_var_P2_file <- "~/SK_Lab/PhD_Projects/LOH_methods/Overton_etal_2022/data/int/Overton_allVar_P2_2023_08.RData"
  # save(all_var_P2, file = all_var_P2_file)
  # all_var_P2 <- all_var_P2 %>% filter(grepl("F_A", ID))
  # Translate positions for P2 callset to Ref positions
  all_var_P2 <- all_var_P2 %>%
    ConstructLiftover(.,  chain_df = P2toRefChainDf, 
                      chrom_from = chrom_bounds_P2,
                      chrom_to = chrom_bounds_Ref)
  
  # all_var_P2_lo <- all_var_P2 %>%
  #   filter(ID == "F_A00") %>%
  #   ConstructLiftover(.,  chain_df = P2toRefChainDf, 
  #                     chrom_from = chrom_bounds_P2,
  #                     chrom_to = chrom_bounds_Ref)
  
  iSNP_P2 <- nchar(all_var_P2$REF) == 1 & nchar(all_var_P2$ALT) == 1
  
  refName_in_ID_P1 <- grepl(paste0("_", P1), all_var_P1$ID[1])
  refName_in_ID_P2 <- grepl(paste0("_", P2), all_var_P2$ID[1])
  
  if(refName_in_ID_P1) {
    all_var_P1 <- all_var_P1 %>% mutate(ID = str_replace(ID, paste0("_", P1), ""))
  }
  if(refName_in_ID_P2) {
    all_var_P2 <- all_var_P2 %>% mutate(ID = str_replace(ID, paste0("_", P2), ""))
  }
  
  if(exists("subset_key")) {
    all_var_P1 <- all_var_P1 %>% filter(grepl(subset_key, ID)) 
    all_var_P2 <- all_var_P2 %>% filter(grepl(subset_key, ID))
    iSNP_P1 <- nchar(all_var_P1$REF) == 1 & nchar(all_var_P1$ALT) == 1
    iSNP_P2 <- nchar(all_var_P2$REF) == 1 & nchar(all_var_P2$ALT) == 1
    
    SNPs_merge <- merge(all_var_P1_lo[iSNP_P1, ] %>% filter(ID == "F_A00"), 
                        all_var_P2_lo[iSNP_P2, ] %>% filter(ID == "F_A00"), 
                        by = by_cols, all = T, 
                        suffixes = c("_P1call", "_P2call"), 
                        sort = F) %>% arrange(ID, POSi)
  }

  # Merge P1 and P2 data frames by position and clone


  SNPs_merge <- merge(all_var_P1[iSNP_P1, ], 
                      all_var_P2[iSNP_P2, ], 
                      by = by_cols, all = T, 
                      suffixes = c("_P1call", "_P2call"), 
                      sort = F) %>% arrange(ID, POSi)
  
  SNPs_merge %>% summarise(n_tot = length(POSi),
                           n_P1 = sum(!is.na(REF_P1call)),
                           n_na_P1 = sum(is.na(REF_P1call)),
                           n_P2 = sum(!is.na(REF_P2call)),
                           n_na_P2 = sum(is.na(REF_P2call)),
                           n_match = sum(!is.na(REF_P1call) & !is.na(REF_P2call)),
                           p_match = 2 * n_match/(n_P1 + n_P2))

  rm(all_var_P1)
  rm(all_var_P2)
  gc()
  
  SNPs_merge <- SwapCrossedAlleles(SNP_df = SNPs_merge,
                                   to_match = "P1call", to_swap = "P2call")
  
  # Remove sites that are in the rRNA repeat region and known Ty elements
  ###############################################################################
  
  rRNA_POSi_seq <- SNPs_merge %>% distinct(POSi) %>% 
    filter(POSi >= rRNA_POSi$POSi[1], POSi <= rRNA_POSi$POSi[2]) %>% pull(POSi)
  SNPs_merge <- SNPs_merge %>% filter(!POSi %in% rRNA_POSi_seq)
  
  Ty_POSi_seq <- SNPs_merge %>% distinct(POSi) %>% 
    filter(POSi >= Ty_POSi$POSi[1], POSi <= Ty_POSi$POSi[2]) %>% pull(POSi)
  SNPs_merge <- SNPs_merge %>% filter(!POSi %in% Ty_POSi_seq)
  
  SNPs_merge$repeats <- MarkRepeats(SNPs_merge, repeats_in = repeats_bed)
  SNPs_merge <- SNPs_merge %>% filter(!repeats) %>% select(-repeats)
  
  # perform final genotyping
  SNPs_merge_finalGT <- SNPs_merge %>% 
    GenotypeFromGQ(., P1_ID = "P1call", P2_ID = "P2call",
                   baseThrsh = 50, naThrsh = 100, diffThrsh = 30) %>%
    filter(GT != "./.", GQ >= 50)
  
  rm(SNPs_merge)
}

# Fill in depth information, standardize column names, drop levels, 
# find annotated SNPs from P2xP1 tables
SNPs_merge_finalGT <- SNPs_merge_finalGT %>% 
                        AddDPinfo() %>%
                        mutate(Anc = ID %in% anc_ID)


# Remove all calls with insufficient support
# Het - at least three reads for each allele
# Hom - at least three reads supporting allele
SNPs_merge_finalGT <- SNPs_merge_finalGT %>%
  filter(!(GT == "0/1" & (Ref_DP_final <= 3 | Alt_DP_final <= 3)),
         !(GT == "1/1" & Alt_DP_final <= 3),
         !(GT == "0/0" & Ref_DP_final <= 3)) 


# SNPs_merge_finalGT$existing_SNP <- SNPs_merge_finalGT$POSi %in% P2xP1_SNPs_POSi

# Mark heterozygous calls that have excessive allele imbalance
# SNPs_merge_finalGT$Cut <- MarkDubiousHets(SNPs_merge_finalGT, anc_id = anc_ID,
#                                           n_consens = 17, .alpha = 0.05, 
#                                           known_hets = "anc_empirical")


# SNPs_merge_finalGT %>% filter(GT == "0/1") %>% count(Cut, Cut_2) %>% mutate(p = n/sum(n))

# Are there any duplicated positions in any clones?
# SNPs_merge_finalGT %>%
#   count(ID, POSi) %>% 
#   filter(n > 1) %>% nrow()

# load(file = SNPs_merge_filename)

# Count each genotype for each site across founder clones and 
# end-point clones independently
# sitewise_GTs <- SNPs_merge_finalGT %>%
#   ungroup() %>%
#   filter(QUAL_P1call >= 1000, QUAL_P2call >= 1000, !Cut) %>%
#   CalcGenoStats(group = "all", anc_id = anc_ID)
# 
# sitewise_GTs_unCut <- SNPs_merge_finalGT %>%
#   ungroup() %>%
#   filter(QUAL_P1call >= 1000, QUAL_P2call >= 1000) %>%
#   CalcGenoStats(group = "all", anc_id = anc_ID)


